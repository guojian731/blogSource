---
title: java多线程-概念、难点汇总
date: 2018-07-11 01:16:51
tags: java多线程
---

##  线程创建的方式 ##

- 继承Thread类
- 继承runnable接口

### 两种方式比较 ###



1. 面向对象编程：
   继承Thread类用的是继承技术，继承runnable接口是以Runaable接口实例为构造器参数直接通过new创建实例，是一种组合的技术。第二种方式类和类之间的耦合性更低，一般组合是优先选用的技术。
2. 对象共享角度:
   第二种方式可以创建一个Runnable实例，多线程可以共享一个Runnable实例。而第一种方法不行。

3. 从创建对象的角度：
   假如我们只是想单纯调用类中的方法，而第一种是创建线程，那么需要耗费更多的资源，我们新建第二种方式的对象就是普通的对象。

## 线程的安全性 ##

### 原子性 ###
我们在事务上经常能听到这个词，原子性的概念必须要依托于外界，就是该操作在外界看来是不可分割的，那么就是原子操作，该操作具有原子性。
- *double、long写操作不是原子性*
  在32的系统下，double、long是线程不安全的，主要的原因是double和long是64位的，所以有一个转化的过程，所以double、long的写操作不是原子性的。除了double、long之外的其他基本类型(byte、boolean、short、char、float、int)的写操作都是原子性的。
- *为什么i++是线程不安全的？*
  这就需要从原子性来讲，因为i++这个操作相当于取i的值，做+1运算，再将值做赋给i，这是一个整套的动作。但是这期间，别的线程也会读取i的值，所以i++不是原子性的，也就是线程不安全的。
- *原子性的保证：*
  使用锁：保障一个共享变量在同一时间只允许一个线程进行访问，消除了竞态。
  使用CAS：实现的实质与锁是一样的，锁是在软件这一层次实现的，CAS直接在硬件（处理器和内存）这一层次实现的，所以被看做“硬件锁”。
### 可见性 ###
  在多线程的环境下，一个线程对某个共享变量进行更新的时候，后续访问该变量的线程可以无法立刻读取这个更新的结果，甚至永远无法读取到这个更新的结果。
### 有序性 ###
  重排序是对内存访问有关的操作（度和写）所做的优化，他可以在不影响单线程程序正确性的情况下提升程序的性能，但是在多线程的情况下可能会对正确性产生影响，可能导致线程安全的问题。

## volatile关键字 ##

**volatile关键字的作用：保障了可见性、有序性以及long、double型变量读写操作的原子性。**之前说过，"long/double"的写操作在32位系统上不是原子性的，他可以保证"long/double"写操作的原子性。

- 实现原理：
  volatile变量不会被编译器分配到寄存器进行存储，读写操作都是内存访问(访问告诉缓存相当于主内存)操作。
- voliate与锁的区别：
  volatile关键字会被称为轻量锁，它可以跟锁一样保证可见性和有序性，原子性上只能保障volatile写操作的原子性，但是没有锁的排他性(int中i++的问题);其次volatile关键字使用，不会引起上下文的切换。
- volatile变量的开销：
  volatile变量的读写操作都不会引起上下文切换，volatile变量的开销要比锁要小。因为是放在内存中，所以volitile的写操作成本在于普通变量的写操作和在临界区内进行的写操作之间。读操作需要访问内存，而不是访问各自的寄存器，所以发挥不了访问的高效性。


## CAS操作 ##

  **CAS只能保障共享变量更新操作的原子性，他并不保障可见性。**
使用场景  之前我们想要保证i++的线程安全性来说，需要用synchronized，但是锁是非常消耗资源的，我们可以用CAS这种方式来解决"read-modify-write"的问题。

- 如何工作：
CAS相当于一个管理人，它存储着共享变量V。如果一个线程像修改这个共享变量的值的时候，这时候线程需要将自己看见当前共享变量的值A，与V的值进行比较，如果相当，说明其他线程没有改过，然后将值改成B。如果发现A的值与V的值不一样了，说明了其他线程已经将这个值改过了，所以请求就失败了，通常失败了之后可以再次尝试，直到成功。

- 伪代码：

``` java 
  
  boolean compareAndSwap(Variable V,Object A,Object B){
        if(A==V.get()){//check:检查变量值是否被其他线程修改过
        V.set(B);//act:更新变量值
        return true;//更新成功
        }
        return false;//变量值已被其他线程修改，更新失败
  }
```

  **注意！！！CAS只能保证共享变量更新操作的原子性，他并不保障可见性。所以需要在变量前使用volatile保证它的可见性。**
  
  **Atomic家族的类都是根据CAS来实现变量的"read-modify-write"，他们都是共享变量更新操作的原子性，也保障可见性。**
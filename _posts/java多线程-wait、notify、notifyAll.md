---
title: java多线程-wait、notify、notifyAll
date: 2018-07-16 19:53:45
tags: java多线程
---

昨天做了一篇每日一问的文章，这种Q和A的方式我觉得会更好地让人知道重点和重点，在这边文章之后多少都会使用Q和A的方式进行汇总。
前提首先是需要有共享变量，这个变量如果满足不满足条件，该线程执行wait就会处于等待状态，但是这个变量不会永远处于不满足状态，当共享变量满足条件后，再将线程唤醒。wait()的作用就是将线程进行等待，notify()的作用就是唤醒一个被暂停的线程。

很显然，提到了贡献变量，所以这个过程是原子性的，必须在synchronize修饰过的方法或者代码块中才能使用wait()。（也就是说，调用一个对象的wait方法，必须获得这个对象的内部锁）

在Object对象中，维护了一个因为该对象暂停的线程队列，该对象wait()的时候就会往队列里添加一个，notify()的时候就会唤醒其中一个线程。所以wait()、notify()在Object类里能更好的管理。

wait()方法会释放该对象的内部锁，试想一下，别人线程需要更改该对象(共享变量)的状态，首先需要获取该对象的锁，如果wait()方法不释放锁，其他线程又怎么能获得锁呢。（wait()方法暂停当前线程释放的锁只是wait对象所属对象的内部锁，当前线程持有的其他锁、显示锁并不会因此而释放）。

wait()方法并不是简单的释放锁、暂停线程就结束了。而是包括加入等待集，暂停当前线程、释放锁以及将唤醒后的等待线程从等待集中移除等，都是在Object.wait()中实现的。wait()伪代码：

``` java 
public void wait(){
	atomic{//原子操作开始
	//释放当前内部锁
	releaseLock(this);
	//暂停当前线程
	block(Thread.currentThread());//语句1
	}//原子操作结束

	//再次申请当前对象的内部锁
	acquireLock(this);//语句2
	//将当前线程从当前对象的等待中移除
	removeFromWaitSet(Thread.currentThread());
	return;//返回
}
```

等待线程在语句1执行的时候被暂停了。被唤醒的线程在其占用处理器继续运行的时候会继续执行其他暂停前调用的Object.wait()中的其他指令，即从上述代码中的语句2开始继续执行：先再次申请Object.wait()所属对象的内部锁，接着将当前线程从相应的等待线程中移除，然后Object.wait()调用才返回。

Object.wait()的执行线程会一直处于Waiting状态，知道通知线程唤醒该线程并且保护条件成立。因此，Object.wait()所实现的等待是无限等待，而Object.wait(long)允许我们指定一个超时时间，如果被暂停的等待线程在这个时间内没有被其他线程唤醒，那么Java虚拟机会自动唤醒该线程。不过Object.wait(long)即无返回值也不会抛出特定的异常，以便区分其返回是由于其他线程通知了当前线程还是由于等待超时。因为，使用Object.wai(long)的时候我们需要一些额外的处理。

1.现在有一个大的水桶100L，每三秒会有机器将水桶注满;有三个管道可以输出水，每个人都可以申请水0~100L,如果申请的水资源不够或者没有空余的管道，就需要等待。

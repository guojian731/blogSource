---
title: JVM-6-垃圾回收概念与算法
date: 2017-12-12 02:09:45
tags: JVM
---

GC中的垃圾，特指存在于内存中的、不会被使用的对象，而“回收”，相当于把垃圾桶“倒掉”。

常用的垃圾回收算法

# 1、引用计数法
对于一个对象A，任何一个对象引用了A，则A的计数器+1，当引用失效后，引用计数器-1。只要对象A的计数器为0，那么A对象就不会被引用。

它有两个严重的问题：

**无法处理循环引用的情况。因此，在Java的垃圾回收器中，没有使用这种算法。**

**引用计数器要求在每次因引用产生和消除时，需要伴随一次加法操作和减法操作，对系统性能呢个有一定的影响。**

例子：如果A、B对象相互引用，计数器均不为0，但是没有第三个对象引用他们，A，B应该是被回收的对象，但是由于他们两个相互引用，从而使垃圾回收期无法识别，引起内存泄漏。

# 2、标记清除法

标记清除法是现代垃圾回收算法的思想基础。标记清除算法将垃圾回收分为两个阶段：标记阶段和清除阶段。一个可行的实现是，在标记阶段，首先通过根节点，标记所有从根节点开始的可达对象。因此，未被标记的对象就是未被引用的垃圾对象。然后，在清除阶段，清除所有未被标记的对象。标记清除算法可能产生最大的为题是空间碎片。

**标记清除算法先通过根节点标记所有可达对象，然后清除所有不可达对象，回收的空间是不连续的，不连续的空间的工作效率要低于连续的空间。这就是该算法最大的缺点。**

# 3、复制算法

复制算法的核心思想：将原有的空间内存分为两块，每次只使用其中一块，在垃圾回收时，将正在使用内存中的存活对象复制到未使用的内存块中，之后，清除正在使用的内存块中的所有对象，交换两个内存的角色，完成垃圾回收。

当需要回收的垃圾对象很多，需要复制的对象很少的时候，这个算法效率是很高的。此算法是不会产生空间碎片的，但是复制算法的代价就是将系统内存折半，因此单纯的复制算法让人难以接受。

在Java新生代的串行收集器中，使用了复制算法的思想。新生代分为eden空间，from区和to区三个部分。from区和to区就是两块内存大小相等，地位相等，可进行角色转换的内存块。from和to空间也被成为survivor空间，即存活者空间，用于存放未被回收的对象。

# 4、标记压缩法

因为复制算法适合只使用于垃圾对象多，存活对象少的情况，那么老年代这种垃圾对象少，存活对象多的情况，是不适合用复制算法的。标记压缩算法也是从根节点开始，对所有可达的对象做一次标记，它并不是简单的清理未标记的对象，而是将所有存活的对象压缩到内存的另一端，然后清理边界之外的所有对象。
标记压缩算法最终效果等同于标记清除法执行完成后，再进行一次内存碎片整理，因此，也可以把它成为标记清除压缩算法。

# 5、分代算法

前面的几种算法，他们没法完全替代其他算法，都有自己的优点和缺点。根据垃圾回收对象的特性，使用合适的算法回收，才是明智的选择。
分代算法就是基于这种思想，它将内存区间根据对象的特点分为几块，根据每块内存区间的特点，使用不同的回收算法，一提高垃圾回收的效率。

# 6、分区算法

分区算法将按照对象的生命周期长短划分成两个部分，分区算法将整个堆空间划分成连续的不同的小区间。每一个小区间都独立使用，独立回收。这种算法的好处是可以控制一次回收多少个小区间。

一般来说，在相同条件下，堆空间越大，一次GC所需要的时间越长，从而产生的停顿越长，即stop-the-world。为了更好的控制GC产生的停顿时间，将一块大的内存区域分割成多个小块，根据目标的停顿时间，每次合理的回收若干个小区间，而不是整个堆空间，从而减少一次GC的停顿。

jdk1.8中的G1垃圾回收器就是使用的这种方法。
